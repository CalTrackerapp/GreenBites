import { db } from "../index.ts"; 
import * as schema from "../db/schema.ts";
import { eq, and } from 'drizzle-orm';
import { foodLog } from "../db/schema.ts";
//data retrieved from each method assumes that the foodID and userID provided exist in their respective tables from the API calls

type FoodLogData = { // data type for creating a food log entry
    logID?: number; // Optional - auto-generated by database
    userID: string;
    foodID: string;
    servingSize: number;
};

async function calculateCalories(foodID: string, servingSize: number): Promise<number> { //returns total calories for the serving size
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);

    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }

    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }

    if (first.calories == null) {
        throw new Error(`Calories value for food ID "${foodID}" is missing.`);
    }

    return first.calories * servingSize;
}

async function calculateProtein(foodID: string, servingSize: number): Promise<number> { // returns protein in grams
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);
    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }   
    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }   
    if (first.proteinInGrams == null) {
        throw new Error(`Protein value for food ID "${foodID}" is missing.`);
    }   
    return first.proteinInGrams * servingSize;
}

async function calculateCarbs(foodID: string, servingSize: number): Promise<number> { // returns carbs in grams
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);
    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }   
    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    } 
    if (first.carbsInGrams == null) {
        throw new Error(`Carbs value for food ID "${foodID}" is missing.`);
    }
    return first.carbsInGrams * servingSize;
}

async function calculateFats(foodID: string, servingSize: number): Promise<number> { // returns fats in grams
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);
    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    if (first.fatInGrams == null) {
        throw new Error(`Fats value for food ID "${foodID}" is missing.`);
    }
    return first.fatInGrams * servingSize;
}

async function calculateCO2Expense(foodID: string, servingSize: number): Promise<number> { // returns CO2Expense
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);
    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    if (first.CO2Expense == null) {
        throw new Error(`CO2Expense value for food ID "${foodID}" is missing.`);
    }
    return first.CO2Expense * servingSize;
}

async function calculateSodium(foodID: string, servingSize: number): Promise<number> { // returns sodium in mg
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);
    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    if (first.sodiumInMg == null) {
        throw new Error(`Sodium value for food ID "${foodID}" is missing.`);
    }
    return first.sodiumInMg * servingSize;
}


export async function calculateCalorieHistoryByDate(
  username: string,
  date: string
): Promise<{
  date: string;
  caloriesToday: number;
  proteinToday: number;
  carbsToday: number;
  fatsToday: number;
  sodiumToday: number;
  carbonFootPrintToday: number;
}> {
  // Get all food logs for this user on the given date
  const foodLogs = await db
    .select()
    .from(schema.foodLog)
    .where(
      and(
        eq(schema.foodLog.userID, username),
        eq(schema.foodLog.loggedAt, new Date(date))
      )
    );

  let caloriesToday = 0;
  let proteinToday = 0;
  let carbsToday = 0;
  let fatsToday = 0;
  let sodiumToday = 0;
  let carbonFootPrintToday = 0;

  for (const log of foodLogs) {
    caloriesToday += await calculateCalories(log.foodID, log.servingSize);
    proteinToday += await calculateProtein(log.foodID, log.servingSize);
    carbsToday += await calculateCarbs(log.foodID, log.servingSize);
    fatsToday += await calculateFats(log.foodID, log.servingSize);
    sodiumToday += await calculateSodium(log.foodID, log.servingSize);
    carbonFootPrintToday += await calculateCO2Expense(log.foodID, log.servingSize);
  }

  return {
    date,
    caloriesToday,
    proteinToday,
    carbsToday,
    fatsToday,
    sodiumToday,
    carbonFootPrintToday,
  };
}

async function alterUserTotals(username: string, calories: number, protein: number, carbs: number, fats: number, sodium: number, totalCO2Expense: number) { // updates user's total nutritional values by ADDING to existing totals
    // Get current user totals
    const currentUser = await db.select().from(schema.users).where(eq(schema.users.username, username)).limit(1);
    
    if (currentUser.length === 0) {
      throw new Error(`User ${username} not found`);
    }
    
    const user = currentUser[0];
    
    // Add new values to existing totals
    await db.update(schema.users)
    .set({
      totalCalories: (user.totalCalories || 0) + calories,
      totalProtein: (user.totalProtein || 0) + protein,
      totalCarbs: (user.totalCarbs || 0) + carbs,
      totalFats: (user.totalFats || 0) + fats,
      totalSodium: (user.totalSodium || 0) + sodium,
      totalCarbonFootPrint: (user.totalCarbonFootPrint || 0) + totalCO2Expense,
    })
    .where(eq(schema.users.username, username));

}

export async function getAllFoodLogs(username: string) {
  return await db
    .select()
    .from(schema.foodLog)
    .where(eq(schema.foodLog.userID, username));
}


// export async function createFoodLogEntry(data: FoodLogData) {
//   const calories = await calculateCalories(data.foodID, data.servingSize);
//   const protein = await calculateProtein(data.foodID, data.servingSize);
//   const carbs = await calculateCarbs(data.foodID, data.servingSize);
//   const fats = await calculateFats(data.foodID, data.servingSize);
//   const sodium = await calculateSodium(data.foodID, data.servingSize);
//   const carbonFootPrintValue = await calculateCO2Expense(data.foodID, data.servingSize);

//   const result = await db.insert(schema.foodLog).values({
//     userID: data.userID,
//     foodID: data.foodID,
//     servingSize: data.servingSize,
//     calories,
//     protein,
//     carbs,
//     fats,
//     sodium,
//     carbonFootPrintValue
//   }).returning();

//   await alterUserTotals(
//     data.userID,
//     calories,
//     protein,
//     carbs,
//     fats,
//     sodium,
//     carbonFootPrintValue
//   );

//   return result;
// }

//update to method above

export async function createFoodLogEntry(userID: string, data: {
  name: string;
  date: string;
  servingSize: number;
  calories: number;
  proteinInGrams: number;
  carbsInGrams: number;
  fatInGrams: number;
  sodiumInMg: number;
  CO2Expense: number;
}) {
  // Insert directly using provided values
const result = await db.insert(foodLog).values({
  userID,
  foodID : data.name, // Assuming foodID is same as name here, adjust if needed
  name: data.name,
  servingSize: data.servingSize,
  calories: data.calories,
  protein: data.proteinInGrams,
  carbs: data.carbsInGrams,      
  fats: data.fatInGrams,         
  sodium: data.sodiumInMg,       
  carbonFootPrintValue: data.CO2Expense,
}).returning();


  // Update user totals
  await alterUserTotals(
    userID,
    data.calories,
    data.proteinInGrams,
    data.carbsInGrams,
    data.fatInGrams,
    data.sodiumInMg,
    data.CO2Expense
  );

  return result;
}


export async function deleteFoodLogEntry(logID: number, userId: string) {
  return await db
    .delete(schema.foodLog)
    .where(
      and(
        eq(schema.foodLog.logID, logID),
        eq(schema.foodLog.userID, userId)
      )
    );
}


