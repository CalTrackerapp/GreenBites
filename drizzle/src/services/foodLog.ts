import { db } from "../index.ts"; 
import * as schema from "../db/schema.ts";
import { eq, and } from 'drizzle-orm'; 
//data retrieved from each method assumes that the foodID and userID provided exist in their respective tables from the API calls

type FoodLogData = { // data type for creating a food log entry
    logID?: number; // Optional - auto-generated by database
    userID: string;
    foodID: string;
    servingSize: number;
};

async function calculateCalories(foodID: string, servingSize: number): Promise<number> { //returns total calories for the serving size
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);

    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }

    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }

    if (first.calories == null) {
        throw new Error(`Calories value for food ID "${foodID}" is missing.`);
    }

    return first.calories * servingSize;
}

async function calculateProtein(foodID: string, servingSize: number): Promise<number> { // returns protein in grams
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);
    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }   
    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }   
    if (first.proteinInGrams == null) {
        throw new Error(`Protein value for food ID "${foodID}" is missing.`);
    }   
    return first.proteinInGrams * servingSize;
}

async function calculateCarbs(foodID: string, servingSize: number): Promise<number> { // returns carbs in grams
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);
    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }   
    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    } 
    if (first.carbsInGrams == null) {
        throw new Error(`Carbs value for food ID "${foodID}" is missing.`);
    }
    return first.carbsInGrams * servingSize;
}

async function calculateFats(foodID: string, servingSize: number): Promise<number> { // returns fats in grams
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);
    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    if (first.fatInGrams == null) {
        throw new Error(`Fats value for food ID "${foodID}" is missing.`);
    }
    return first.fatInGrams * servingSize;
}

async function calculateCO2Expense(foodID: string, servingSize: number): Promise<number> { // returns CO2Expense
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);
    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    if (first.CO2Expense == null) {
        throw new Error(`CO2Expense value for food ID "${foodID}" is missing.`);
    }
    return first.CO2Expense * servingSize;
}

async function calculateSodium(foodID: string, servingSize: number): Promise<number> { // returns sodium in mg
    const food = await db.select().from(schema.foods).where(eq(schema.foods.foodID, foodID)).limit(1);
    if (food.length === 0) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    const first = food[0];
    if (!first) {
        throw new Error(`Food with ID "${foodID}" not found.`);
    }
    if (first.sodiumInMg == null) {
        throw new Error(`Sodium value for food ID "${foodID}" is missing.`);
    }
    return first.sodiumInMg * servingSize;
}

async function alterUserTotals(username: string, calories: number, protein: number, carbs: number, fats: number, sodium: number, totalCO2Expense: number) { // updates user's total nutritional values by ADDING to existing totals
    // Get current user totals
    const currentUser = await db.select().from(schema.users).where(eq(schema.users.username, username)).limit(1);
    
    if (currentUser.length === 0) {
      throw new Error(`User ${username} not found`);
    }
    
    const user = currentUser[0];
    
    // Add new values to existing totals
    await db.update(schema.users)
    .set({
      totalCalories: (user.totalCalories || 0) + calories,
      totalProtein: (user.totalProtein || 0) + protein,
      totalCarb: (user.totalCarb || 0) + carbs,
      totalFats: (user.totalFats || 0) + fats,
      totalSodium: (user.totalSodium || 0) + sodium,
      totalCO2Expense: (user.totalCO2Expense || 0) + totalCO2Expense,
    })
    .where(eq(schema.users.username, username));

}

export async function getAllFoodLogs(username: string) {
  return await db
    .select()
    .from(schema.foodLog)
    .where(eq(schema.foodLog.userID, username));
}


export async function createFoodLogEntry(data: FoodLogData) { // creates a new food log entry
    // logID is auto-generated by database (serial), so we don't include it
    const result = await db.insert(schema.foodLog).values({
        userID: data.userID,
        foodID: data.foodID,
        servingSize: data.servingSize,
    }).returning(); 

    await alterUserTotals(
        data.userID,
        await calculateCalories(data.foodID, data.servingSize),
        await calculateProtein(data.foodID, data.servingSize),
        await calculateCarbs(data.foodID, data.servingSize),
        await calculateFats(data.foodID, data.servingSize),
        await calculateSodium(data.foodID, data.servingSize),
        await calculateCO2Expense(data.foodID, data.servingSize)
    );

    return result;
}

export async function deleteFoodLogEntry(logID: number, userId: string) {
  return await db
    .delete(schema.foodLog)
    .where(
      and(
        eq(schema.foodLog.logID, logID),
        eq(schema.foodLog.userID, userId)
      )
    );
}

// Calculate today's totals from food logs
export async function calculateTodayTotals(username: string, date: string): Promise<{
  caloriesToday: number;
  proteinToday: number;
  carbsToday: number;
  fatsToday: number;
  sodiumToday: number;
  carbonFootPrintValueToday: number;
}> {
  // Get all food logs for the user
  const foodLogs = await getAllFoodLogs(username);
  
  // Filter logs for today (date format: "YYYY-MM-DD")
  const todayLogs = foodLogs.filter(log => {
    if (!log.loggedAt) return false;
    const logDate = new Date(log.loggedAt);
    const logDateStr = logDate.toISOString().split('T')[0]; // Get YYYY-MM-DD
    return logDateStr === date;
  });

  // Calculate totals from today's logs
  let caloriesToday = 0;
  let proteinToday = 0;
  let carbsToday = 0;
  let fatsToday = 0;
  let sodiumToday = 0;
  let carbonFootPrintValueToday = 0;

  for (const log of todayLogs) {
    const calories = await calculateCalories(log.foodID, log.servingSize);
    const protein = await calculateProtein(log.foodID, log.servingSize);
    const carbs = await calculateCarbs(log.foodID, log.servingSize);
    const fats = await calculateFats(log.foodID, log.servingSize);
    const sodium = await calculateSodium(log.foodID, log.servingSize);
    const co2 = await calculateCO2Expense(log.foodID, log.servingSize);
    
    caloriesToday += calories;
    proteinToday += protein;
    carbsToday += carbs;
    fatsToday += fats;
    sodiumToday += sodium;
    carbonFootPrintValueToday += co2;
  }

  return {
    caloriesToday: Math.round(caloriesToday),
    proteinToday: Math.round(proteinToday),
    carbsToday: Math.round(carbsToday),
    fatsToday: Math.round(fatsToday),
    sodiumToday: Math.round(sodiumToday),
    carbonFootPrintValueToday: Math.round(carbonFootPrintValueToday),
  };
}


