# ADR-001: Initial Technology Stack Selection

## Status
Accepted

## Context
We needed to choose a technology stack for building GreenBites, a full-stack nutrition and sustainability tracking application. The project required:
- A modern frontend framework with strong TypeScript support
- A backend solution that could handle API routes and database operations
- Authentication system for user management
- Database solution for persisting user data, food logs, and nutrition information
- State management for complex user data and calorie tracking
- Styling solution for rapid UI development

Key constraints:
- Team members had varying levels of experience with different technologies
- Need for type safety to prevent runtime errors
- Scalability for future feature additions
- Fast development velocity
- Good developer experience and documentation

## Decision
We will use **Next.js 15 with React 19 and TypeScript** as our primary framework because:
1. Full-stack capabilities with API routes built-in
2. Excellent TypeScript support out of the box
3. Server-side rendering and static generation capabilities
4. Strong ecosystem and community support
5. App Router provides modern routing patterns

We will use **Clerk** for authentication because:
1. Pre-built components and middleware
2. Social login support
3. User management without building from scratch
4. Secure and scalable

We will use **PostgreSQL with Drizzle ORM** for data persistence because:
1. Type-safe queries with TypeScript
2. Relational data model fits our needs (users, foods, foodLogs)
3. Migration system for schema evolution
4. Cloud hosting options (Supabase/Neon) for easy deployment

We will use **React Context API with useReducer** for state management because:
1. Built into React (no additional dependencies)
2. Sufficient for our current state complexity
3. Predictable state updates
4. Easy to understand and maintain

We will use **Tailwind CSS** for styling because:
1. Utility-first approach speeds up development
2. Consistent design system
3. Responsive design made easy
4. Small bundle size with purging

## Consequences

### Positive
- Fast development velocity with Next.js App Router
- Type safety throughout the stack reduces bugs
- Clerk handles complex authentication logic
- Drizzle provides type-safe database queries
- Tailwind enables rapid UI iteration
- Single framework (Next.js) for frontend and backend simplifies deployment

### Negative
- Learning curve for Next.js App Router (team had more Express experience initially)
- Context API may need refactoring if state becomes more complex
- Migration from Express to Next.js required some rework
- Drizzle ORM has less community resources compared to Prisma

## Alternatives Considered

### Option 1: Express.js + React (Separate Frontend/Backend)
- **Pros**: Team had more experience with Express, clear separation of concerns
- **Cons**: More complex deployment, CORS issues, separate codebases
- **Decision**: Chose Next.js for unified full-stack solution and better DX

### Option 2: Prisma ORM
- **Pros**: More mature, larger community, excellent tooling
- **Cons**: Heavier, more opinionated, larger bundle size
- **Decision**: Chose Drizzle for lighter weight and better TypeScript integration

### Option 3: Redux Toolkit
- **Pros**: Powerful state management, excellent DevTools, team member had experience
- **Cons**: More boilerplate, overkill for current needs, additional dependency
- **Decision**: Started with Redux but migrated to Context API for simplicity

### Option 4: Auth0 or Firebase Auth
- **Pros**: Well-established, feature-rich
- **Cons**: More complex setup, potentially more expensive
- **Decision**: Chose Clerk for better Next.js integration and simpler setup

## Notes
- We initially started with Express.js for API routes but migrated to Next.js API routes in Week 8 for better integration
- Redux was implemented in Week 3 but we migrated to Context API in Week 4 for simplicity
- The stack has proven flexible enough to accommodate our evolving requirements
- Future considerations: May need to revisit state management if we add real-time features or more complex state
